from typing import Dict, List
import networkx as nx
import sys

def main():
    minimizeLatency = False
    minimizeMemory = False
    schedulingMethod = ""

    # createGraph()
    nodeWeights = {}
    # findAllPaths()
    allPaths = []
    # ASAPNodes()
    nodesASAP = {}
    # ALAPNodes()
    nodesALAP = {}
    # slack()
    nodesSlack = {}
    # createVariables()
    variables = {}
    # variablesWithSteps()
    variableStrings = {}
    # exeConstraints()
    eConstraint = []
    # depConstraints()
    dConstraint = []
    dConstraintNodes = {}
    # resConstraints()
    rConstraintVars = {}
    rConstraint = []

    if "-l" in sys.argv:
        latencyIndex = sys.argv.index("-l")
        latency =  int(sys.argv.index[latencyIndex + 1])
        minimizeMemory = True

    if "-a" in sys.argv:
        memoryIndex = sys.argv.index("-a")
        memory =  int(sys.argv.index[memoryIndex + 1])
        minimizeLatency = True

    if "-g" in sys.argv:
        fileIndex = sys.argv.index("-g")
        file = sys.argv.index[fileIndex + 1]
            
    if (minimizeLatency & minimizeMemory):
        schedulingMethod = "Pareto-Optimal"
    elif (minimizeLatency & ~minimizeMemory):
        schedulingMethod = "Latency"
    else:
        schedulingMethod = "Memory"

    G = createGraph(file, nodeWeights)

    source = findSource(G)
    sink = findSink(G)

    findAllPaths(G, source, sink, allPaths)

    ASAPNodes(G, nodesASAP, sink)
    ALAPNodes(G, nodesALAP)

    ASAP(allPaths, nodesASAP)
    ALAP(allPaths, nodesALAP, latency)
    slack(nodesASAP, nodesALAP, nodesSlack)

    createVariables(G, variables)

    stepLocations(variables, nodesASAP, nodesALAP)

    variablesWithSteps(variables, variableStrings)

    exeConstraints(eConstraint, variableStrings)

    depConstraints(G, dConstraintNodes, variableStrings, dConstraint)

    resConstraints(variableStrings, rConstraintVars, nodeWeights, memory, rConstraint)

    match schedulingMethod:
        case "Pareto-Optimal":
            print("Do Pareto-Optimal analysis")
        case "Latency":
            G = createGraph(file, nodeWeights)
            source = findSource(G)
            sink = findSink(G)
            findAllPaths(G, source, sink, allPaths)
            ASAPNodes(G, nodesASAP, sink)
            ALAPNodes(G, nodesALAP)
            ASAP(allPaths, nodesASAP)
            longestPath = criticalPath(allPaths)
            for latency in longestPath:
                ALAP(allPaths, nodesALAP, latency)
                slack(nodesASAP, nodesALAP, nodesSlack)
                createVariables(G, variables)
                stepLocations(variables, nodesASAP, nodesALAP)
                variablesWithSteps(variables, variableStrings)
                exeConstraints(eConstraint, variableStrings)
                depConstraints(G, dConstraintNodes, variableStrings, dConstraint)
                resConstraints(variableStrings, rConstraintVars, nodeWeights, memory, rConstraint)
                # write text file
            print("Do latency minimization under resource constraints")
        case "Memory":
            longestPath = criticalPath(allPaths)
            if (longestPath > latency):
                print("infeasible")
                # end minimization
            exeConstraints(eConstraint, variableStrings)
            depConstraints(G, dConstraintNodes, variableStrings, dConstraint)
            for memory in G.nodes(): # Runs resConstraints for any value between 0 and # of nodes
                if (memory == 0):
                    continue
                else:
                    resConstraints(variableStrings, rConstraintVars, nodeWeights, memory, rConstraint)
                    # write text file
            print("Do memory minimization under latency constraints")
        case _:
            print("error")

# Creates and returns the graph G
def createGraph (file : str, nodeWeights : dict({})):
    # Read the DFG from an external file in edge-list format
    filename = file # Pull this from filename
    G = nx.read_weighted_edgelist(filename, nodetype=int)

    # Add source and sink nodes
    firstNode = -1
    G.add_nodes(firstNode)
    lastNode = max(G.nodes())
    G.add_nodes(lastNode + 1)
    lastNode = max(G.nodes())

    # Assign a weight to each node. Node weight is the sum of all fan-out edge weights
    for node in G.nodes():
        nodeWeights.update({node, 0})
    for node in G.nodes():
        if (len(G.nodes(node).successors()) != 0):
            for successor in G.nodes(node).successors():
                nodeWeights[node] = nodeWeights[node] + G[node][successor]["weight"] # G[node][successor]["weight"] should hopefully return the weight of the edge between the node and the successor

    for node in G.nodes():
        if (len(G.nodes(node).successors()) == 0):
            G.remove_node(node)

    for node in G.nodes():
        if (len(G.nodes(node).predecessors()) == 0):
            G.add_edge(-1, node)

    for node in G.nodes():
        if (len(G.nodes(node).successors()) == 0):
            G.add_edge(node, lastNode)
    
    return G

# Finds and returns the source node of the graph
def findSource (G):
    source = min(G.nodes())
    return source

# Finds and returns the sink node of the graph
def findSink (G):
    source = max(G.nodes())
    return source

# Find all paths from source to sink
def findAllPaths (G, src : int, dst : int, allPaths : List[List[int]]):
    path = []
    path.append(src)

    DFS(G, src, dst, path)

# Depth-First Search, called in findAllPaths()
def DFS (G, src : int, dst : int, path : List[int], allPaths : List[List[int]]):
    if (src == dst):
        allPaths.append(copy.deepcopy(path)) # NEED TO CHANGE THIS LINE
    else:
        for adjNode in G.successors(src):
            path.append(adjNode)
            DFS(G, adjNode, dst, path)
            path.pop()

def criticalPath (allPaths):
    longestPath = 0
    for path in allPaths:
        if (len(path) > longestPath):
            longestPath = len(path)

def ASAPNodes (G, nodesASAP : dict({}), lastNode):
    for i in G.nodes():
        nodesASAP.update({i, lastNode})

def ALAPNodes (G, nodesALAP : dict({})):
    for i in G.nodes():
        nodesALAP.update({i, 0})

# Find the earliest step location of each node
def ASAP (allPaths : List[List[int]], nodesASAP : Dict[int, int]):
     for paths in allPaths:
          for nodes in allPaths[paths]:
               #minimize
               if (allPaths[paths[nodes]] < nodesASAP[nodes]):
                    nodesASAP[nodes] = allPaths[paths[nodes]]

# Find the latest step location of each node
def ALAP (allPaths : List[List[int]], nodesALAP : Dict[int, int], latency):
     for paths in allPaths:
          for nodes in allPaths[paths]:
               #maximize
               if ((allPaths[paths[nodes]] > nodesALAP[nodes]) & (allPaths[paths[nodes]] <= latency)):
                    nodesALAP[nodes] = allPaths[paths[nodes]]

def slack (nodesASAP : Dict[int, int], nodesALAP : Dict[int, int], nodesSlack : Dict[int, int]):
     for node in nodesSlack:
          nodesSlack[node] = nodesASAP[node] - nodesALAP[node]

# Creates a dictionary for the variables. Key = node, Value = List of all possible step locations
def createVariables (G, variables):
    for node in G.nodes():
        variables.update({node, List[int]})

# Adds all possible step locations to each list of step locations
def stepLocations (variables, nodesASAP, nodesALAP):
    for node in variables:
        for i in range(nodesASAP[node], nodesALAP[node]):
            variables[node].append(i)

# Creates a dictionary of all variables. Key = node, Value = all variables in "x1_1" form
def variablesWithSteps (variables, variableStrings):
    for node in variables:
        variableStrings.update({node, List[int]})
    for node in variables:
        for step in variables[node]:
            variableString = f"x{node}_{step}"
            variableStrings[node].append(variableString)

# Execution constraint: Each node is only executed once
def exeConstraints (eConstraint, variableStrings):
    for node in variableStrings:
        for i in variableStrings[node]:
            eConstraint.append(variableStrings[node[i]])
            if (i < len(variableStrings[node])):
                eConstraint.append("+")
            else:
                eConstraint.append("=1")

def depConstraints (G, dConstraintNodes, variableStrings, dConstraint):
    # This will make a dictionary where the key is the original node and the values for that key are all successors of that original node
    for node in G.nodes():
        if (len(G.nodes(node).successors()) > 0):
            for successor in G.nodes(node).successors():
                dConstraintNodes.update({node, successor})

    # Loop through all nodes and all successors in dConstraintNodes.
    index = 0
    for node in dConstraintNodes:
        for successor in dConstraintNodes[node]:
            eqString = ""
            for var in variableStrings:
                string = f"x{node}_"
                if (var.contains(string)):
                        vars = var.split("_")
                        weight = vars[1]
                        eqString.append(weight + node + "+") # Need to figure out how to not add a "+" on the last value
            eqString = eqString.rstrip(eqString[-1])
            eqString.append(">=")
            for var in variableStrings:
                string = f"x{successor}_"
                if (var.contains(successor)):
                        vars = var.split("_")
                        weight = vars[1]
                        eqString.append(weight + successor + "+") # Need to figure out how to not add a "+" on the last value
            eqString = eqString.rstrip(eqString[-1])
            dConstraint[index].append(eqString)
            index = index + 1

def resConstraints (variableStrings, rConstraintVars, nodeWeights, memory, rConstraint):
    # Makes a dictionary of all the variables and their corresponding weights
    for var in variableStrings:
        rConstraintVars.update({var, None})
    for node in nodeWeights:
        string = f"x{node}_"
        for var in rConstraintVars:
            if (rConstraintVars.contains(string)):
                rConstraintVars[var] = nodeWeights[node]

    # Resource constraint: The nodes executed in each step don't overuse the memory constraint
    for var in variableStrings:
        string = variableStrings[var].split("_")
        step = string[1]
        rConstraint[step].append(var + "+")
    for step in rConstraint:
        string = rConstraint[step]
        rConstraint[step] = string.rstrip(string[-1])
        rConstraint[step].append("<=" + memory)
    
